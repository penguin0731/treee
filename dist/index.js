#!/usr/bin/env node
import{p as t}from"./commander-CXs82Ous.js";import e from"fs";import{g as r}from"./glob-l0vWOJPs.js";import"events";import"child_process";import"path";import"process";import"url";import"fs/promises";import"stream";import"string_decoder";var o="0.0.7";const i={directory:"📁",file:"📄"},s={border:"│",contain:"├",line:"─",last:"└─"},n=Symbol("generateTreeData"),c=Symbol("sort"),a=Symbol("draw");class p{constructor(t){const{directory:e,ignore:r,noIcons:o}=t;this.directory=e,this.ignore=r,this.noIcons=o,this.treeString="",this.init()}static emojiMap={};init(){for(const t in i)p.emojiMap[t]=this.noIcons?"":i[t]}[n](t){const o=e.statSync(t),i=t.replace(/.*\/(?!$)/g,"");if(o.isFile())return i;const s={};let a=r(`${t}/*`,{dot:!0,ignore:this.ignore});return a=a.map((t=>this[n](t))),s[i]=this[c](a),s}[c](t){return t.sort(((t,e)=>"object"==typeof t?-1:"object"==typeof e||t>e?1:-1)),t}[a](t,e=""){const{border:r,contain:o,line:i,last:n}=s;for(const s in t){const c=t[s];"string"==typeof c?this.treeString+=`\n${e}${p.emojiMap.file}${c}`:Array.isArray(c)&&(this.treeString+=`\n${e}${p.emojiMap.directory}${s}`,e=(e=`${e=(e=e.replaceAll(o,r)).replaceAll(new RegExp(`${n}|${i}`,"g"),"")}${Array(Math.ceil(s.length/2)).join(" ")}${o}${i}`).replace(/^ +/g,""),c.forEach(((t,r)=>{r===c.length-1&&(e=e.replace(`${o}${i}`,n)),"string"==typeof t?this.treeString+=`\n${e}${p.emojiMap.file}${t}`:this[a](t,e)})))}}create(){const t=this[n](this.directory);this[a](t),this.treeString=this.treeString.replace(/^\n/,""),console.log(this.treeString)}}const l=process.cwd();t.option("-d, --directory <directory>","specify a directory to create tree",l).option("-i, --ignore <glob...>","ignore directories when you create tree").option("-ni, --noIcons","create tree without icons"),t.version(o,"-v, --version"),t.parse(process.argv);const g=t.opts();new p(g).create();
